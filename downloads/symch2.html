<style>
    .actions-panel {
        position: fixed;
        top: 0;
        left: 0;
    }
    .input-panel {
        position: fixed;
        left: 120px;
    }
    .toggle-textarea {
        top: 0;
        left: 0;
        width: 120px;
    }

    .overlay {
        position: fixed;
        top: 0;
        left: 0;
    }

    body {
        margin: 0;
        padding: 0;
    }

    .buffers {
        position: fixed;
        bottom: 0;
        left: 0;
    }
    .buffer {
        position: relative;
        display: inline-block;
        margin-bottom: 20px;
    }
    #delimiter-textfield {
        width: 30px;
    }
</style>
<script>
    MathJax = {
        loader: { load: ['output/svg'] }
    };
</script>
<script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js"></script>
<script>
    // create a javascript class for each equation
    const MouseState = {
        NONE: 0,
        HOVER: 1,
        SELECTED: 2,
        DRAGGING: 3,
    }
    function removedAligned(code){
        return code.replace('\\begin{aligned}', '').replace('\\end{aligned}', '');
    }
    focused_entity = null;
    function decorateNode(entity,node){
        console.log('inside decorate', entity)
        node.style.position = 'absolute';
        node.style.right = entity.position.right;
        node.style.top = entity.position.top;
        node.onmousedown = entity.onmousedown.bind(entity);
        node.onmousemove = entity.onmousemove.bind(entity);
        node.onmouseup = entity.onmouseup.bind(entity);
        node.onmouseover = entity.onmouseover.bind(entity);
        node.onmouseout = entity.onmouseout.bind(entity);
    }
    document.onmousedown = function (e){
        if(e.target == document.body){
            // unselect the focused entity
            if(focused_entity != null){
                document.getElementById('latex').value = '';
                focused_entity = null;
            }
        }
    }
    function math_rerender(code, entity){
        document.getElementById('output').removeChild(entity.node);
        MathJax.tex2svgPromise(code).then((node) => {
            console.log(node.children[0])
            entity.node = node.children[0];
            decorateNode(entity, entity.node);
            document.getElementById('output').appendChild(entity.node)
        }).catch((err) => {
            console.log("err")
        })
    }
    function latex_onkeyup() {
        console.log('keyup')
        if(document.getElementById('auto-render').checked){
            var textarea = document.getElementById('latex');
            var code = textarea.value;
            code = removedAligned(code);
            code = "\\begin{aligned}" + code + "\\end{aligned}"
            console.log(code)
            if(focused_entity != null){
                focused_entity.code = code;
                math_rerender(code, focused_entity);
            }
        }
    }
    function get_selection() {
        var textarea = document.getElementById('latex');
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;
        var sel = textarea.value.substring(start, end);
        return [start, end, sel];
    }
    function latex_onmouseup(e) {
        // get selection
        save_old_textarea_style();
        const [start, end, sel] = get_selection();
        if (sel.length == 0) {
            return;
        }
        // surround with underbrace
        var textarea = document.getElementById('latex');
        var before = textarea.value.substring(0, start);
        var after = textarea.value.substring(end, textarea.value.length);
        var underbraced = before + "\\underbrace{" + sel + "}" + after;
        underbraced = "\\begin{aligned}" + removedAligned(underbraced) + "\\end{aligned}"
        console.log(underbraced)
        math_rerender(underbraced, focused_entity);
    }
    class Entity {
        constructor(code, node) {
            this.code = code;
            this.node = node;
            this.position = {};
            this.position.right = node.style.right;
            this.position.top = node.style.top;
            this.mouse_state = MouseState.NONE;
        }
        onmouseover(e) {
            if (this.mouse_state != MouseState.DRAGGING) this.mouse_state = MouseState.HOVER;
            this.node.style.border = '1px solid red';
        }
        onmousedown(e) {
            if (e.button == 0) { // left click
                if (this.mouse_state != MouseState.DRAGGING) this.mouse_state = MouseState.SELECTED;
                this.node.style.border = '1px solid blue';
            }else if (e.button == 2) { // right click
                this.mouse_state = MouseState.NONE;
                // select the node
                document.getElementById('latex').value = removedAligned(this.code);
                toggle_textarea(1);
                this.node.style.border = '1px solid green';
                focused_entity = this;
                return;
            }
        }
        onmouseout(e) {
            // console.log('out', e);
            if(focused_entity != this){
                this.node.style.border = '1px solid white';
            }
        }
        onmouseup(e) {
            // console.log('up', e)
            if (e.button == 0) { // left click
                this.mouse_state = MouseState.NONE;
            }
            if(focused_entity != this){
                this.node.style.border = '1px solid white';
            }
        }
        onmousemove(e) {
            if (this.mouse_state == MouseState.SELECTED) {
                this.mouse_state = MouseState.DRAGGING;
            }
            if (this.mouse_state == MouseState.DRAGGING) {
                // change in x and y
                var dx = e.movementX;
                var dy = e.movementY;
                // scale
                const scale = 0.5;
                dx *= scale;
                dy *= scale;
                // move the node
                this.position.right = parseInt(this.position.right) - dx;
                this.position.top = parseInt(this.position.top) + dy;
                this.node.style.right = this.position.right;
                this.node.style.top = this.position.top;
            }
        }
    }
    var entities = [];
    document.addEventListener('contextmenu', event => event.preventDefault());

    function math_render(code) {
        MathJax.tex2svgPromise(code).then((guy) => {
            // console.log(node.children[0])
            // absolute positioning for node 
            var node = guy.children[0];
            node.style.position = 'absolute';
            node.style.top = 0;
            node.style.right = 0;
            const entity = new Entity(code, node);
            decorateNode(entity,node);
            entities.push(entity);
            document.getElementById('output').appendChild(node)
        }).catch((err) => {
            console.log("err")
        })
    }
    function init() {
        document.onmouseup = function (e) {
            for (var i = 0; i < entities.length; i++) {
                entities[i].onmouseup(e);
            }
        }
        document.onmousemove = function (e) {
            for (var i = 0; i < entities.length; i++) {
                entities[i].onmousemove(e);
            }
        }
        document.getElementById('latex').style.visibility = 'hidden';
        math_render('\\begin{aligned} \\left(d+e-\\left[f-g\\right]\\right)\\end{aligned}')
        math_render('\\begin{aligned} -(a+b) \\end{aligned}')
    }
    function add_entity(){
        const raw_latex = document.getElementById('latex').value;
        if(raw_latex.length == 0) return;
        // wrap with aligned
        const aligned = '\\begin{aligned}' + removedAligned(raw_latex) + '\\end{aligned}';
        math_render(aligned);
    }
    function render() {
        init()
        add_entity()
    }
    function delete_entity(){
        if(focused_entity == null) return;
        document.getElementById('output').removeChild(focused_entity.node);
        document.getElementById('latex').value = '';
        focused_entity = null;
    }
    var old_textarea_style = {
        width: '400px',
        height: '150px',
    };
    function save_old_textarea_style(){
        var textarea = document.getElementById('latex');
        old_textarea_style = {
            width: textarea.style.width,
            height: textarea.style.height,
        }
    }
    function show_textarea(){
        var textarea = document.getElementById('latex');
        textarea.style.visibility = 'visible';
        textarea.style.width = old_textarea_style.width
        textarea.style.height = old_textarea_style.height
    }
    function toggle_textarea(force) {
        if(force == 1){
            show_textarea();
            return;
        }
        var textarea = document.getElementById('latex');
        if (textarea.style.visibility == 'hidden') {
            show_textarea();
        } else {
            textarea.style.visibility = 'hidden';
            save_old_textarea_style();
            textarea.style.width = '0px';
            textarea.style.height = '0px';
        }
    }
    class AST {
        constructor(){
            this.operation = null;
            // for binary
            this.left = null;
            this.right = null;
            // for unary
            this.term = null;
        }
        tree(indent=0){
            var output = '';
            const blah = '.'.repeat(indent);
            output += blah;
            output += this.operation;
            output += '\n';
            output += blah;
            if(this.left instanceof AST){
                output += this.left.tree(indent+1);
            }else{
                output += this.left;
            }
            output += '\n';
            output += blah;
            if(this.right instanceof AST){
                output += this.right.tree(indent+1);
            }else{
                output += this.right;
            }
            return output;
        }
        propagate_minus(){
        }
        infix(){
            var infix = '';
            if(this.left instanceof AST){
                infix += '(' + this.left.infix() + ')';
            }else{
                infix += this.left;
            }
            if(this.operation == '-'){
                console.error('minus sign should have been propagated')
            }
            infix += this.operation;
            if(this.right instanceof AST){
                infix += '(' + this.right.infix() + ')';
            }else{
                infix += this.right;
            }
        }
    }
    function construct_AST(postfix, firstDelimiter, secondDelimiter){
        var stack = [];
        for(var i = 0; i < postfix.length; i++){
            if(postfix[i] == ' ') continue;
            if(postfix[i] == firstDelimiter){
                // pop two things from stack
                var right = stack.pop();
                var left = stack.pop();
                // construct AST
                var ast = new AST();
                ast.operation = firstDelimiter;
                ast.left = left;
                ast.right = right;
                // push AST to stack
                stack.push(ast);
            }else if(postfix[i] == secondDelimiter){
                // pop two things from stack
                var right = stack.pop();
                var left = null;
                if(stack.length > 0){
                    left = stack.pop();
                }
                // construct AST
                var ast = new AST();
                if(left == null){
                    ast.operation = 'neg';
                    ast.term = right;
                }else{
                    ast.operation = secondDelimiter;
                    ast.left = left;
                    ast.right = right;
                }
                // push AST to stack
                stack.push(ast);
            }else{
                // push to stack
                stack.push(postfix[i]);
            }
            console.log(stack)
        }
        return stack[0];
    }
    function separate(){
        console.log('separate')
        const delimiter = document.getElementById('delimiter-textfield').value;
        const firstDelimiter = delimiter.split(',')[0];
        const secondDelimiter = delimiter.split(',')[1]; // the minus sign
        var [start, end, sel] = get_selection();
        if(sel.length == 0) sel = removedAligned(focused_entity.code); // if nothing selected, entire thing is selected
        // split sel by firstDelimiter (plus sign) and secondDelimiter (minus sign)
        // taking good care of brackets
        const brackets = [['(', ')'], ['{', '}'], ['[', ']']];
        var operator_stack = [];
        var terms_queue = [];
        // shunt yard algorithm
        for(var i = 0; i < sel.length; i++){
            var is_number = true;
            for(var j = 0; j < brackets.length; j++){
                // if it's a bracket 
                if(sel[i] == '\\'){
                    // skip to the bracket
                    if(sel.substring(i, i+5) == '\\left'){
                        i += 5;
                    }else if(sel.substring(i, i+6) == '\\right'){
                        i += 6;
                    }
                }
                if(sel[i] == brackets[j][0]){ // left bracket
                    operator_stack.push(brackets[j][0]);
                    is_number = false;
                }else if(sel[i] == brackets[j][1]){ // right bracket
                    // pop all operators until left bracket
                    while(operator_stack.length > 0 && operator_stack[operator_stack.length - 1] != brackets[j][0]){
                        terms_queue.push(operator_stack.pop());
                    }
                    operator_stack.pop(); // pop the left bracket
                    is_number = false;
                }
            }
            if (sel[i] == firstDelimiter) {
                // is an operator
                // pop all operators with higher precedence (none)
                operator_stack.push(sel[i]);
                is_number = false;
            } else if (sel[i] == secondDelimiter) {
                operator_stack.push(sel[i]);
                is_number = false;
            }
            if (is_number) {
                // is a term
                terms_queue.push(sel[i]);
            }
        }
        while (operator_stack.length > 0) {
            terms_queue.push(operator_stack.pop());
        }
        console.log(terms_queue);
        // construct an AST
        var ast = construct_AST(terms_queue, firstDelimiter, secondDelimiter);
        // propagate the minus signs to the leafs
        console.log(ast.tree())
        ast.propagate_minus();
        console.log(ast.tree())
        // convert the AST to a infix notation
        var infix = ast.infix();
        console.log(infix);
    }
</script>

<body onload='render()'>

    <!-- <canvas class='workspace' id='output' width='500' height='500'></canvas> -->
    <div id='output'></div>
    <div class="overlay add-entity">
        <div class="input-panel">
            <textarea class="latex-input" id='latex' onkeyup="latex_onkeyup()" onmouseup="latex_onmouseup()">
  W_\alpha &= -\frac{1}{4} \bar{D}^2 D_\alpha V \\
  &= -\frac{1}{4} \bar{D}^2 (-\sigma^\nu_{\alpha\dot\beta} \bar\theta^{\dot\beta} A_\nu + i\theta_\alpha \overline{\theta\lambda} - i \bar\theta^2 \lambda_\alpha + \frac{1}{2} \theta_\alpha \bar{\theta}^2 D - i \sigma_{\alpha \dot\alpha}^\mu \bar\theta^{\dot\alpha} \theta^\beta \sigma_{\beta\dot\beta}^\nu \bar\theta^{\dot\beta} \partial_\mu A_\nu - \sigma_{\alpha \dot \alpha}^\mu \bar\theta^{\dot\alpha} \theta^\beta \theta_\beta \bar\theta^{\dot\beta} \partial_\mu \bar\lambda_{\dot\beta}) \\
  &= (a+b-c) (d-e +f)\\
</textarea><br>
        </div>
        <div class="actions-panel">
            <button class="toggle-textarea" onclick="toggle_textarea()">Toggle Textarea</button><br>
            <button class="add-entity" onclick="add_entity()">Add Entity</button><br>
            <button class="delete-entity" onclick="delete_entity()">Delete</button><br>
            <input type="checkbox" id="auto-render" checked onchange="latex_onkeyup()"> Auto-Render
        </div>
        <div class="buffers">
            <input type="button" value="Copy Buffer" onclick=""> <br> 
            <input type="button" value="Expand" onclick=""> <br> 
            <input type="button" value="Separate" onclick="separate()"> 
            <input type="text" placeholder="Delimiter" value="+,-" id="delimiter-textfield"><br>
            <div class="buffer">
                A:
                <input type="button" value="Rename" onclick=""> 
                <input type="button" value="Delete" onclick=""> 
                <input type="button" value="Render" onclick=""> 
                <select class="buffer-select">
                    <option value="1">Buffer 1</option>
                    <option value="2">Buffer 2</option>
                    <option value="3">Buffer 3</option>
                    <option value="4">Buffer 4</option>
                </select>
            </div><br>
            <div class="buffer">
                B:
                <input type="button" value="Rename" onclick=""> 
                <input type="button" value="Delete" onclick=""> 
                <input type="button" value="Render" onclick=""> 
                <select class="buffer-select">
                    <option value="1">Buffer 1</option>
                    <option value="2">Buffer 2</option>
                    <option value="3">Buffer 3</option>
                    <option value="4">Buffer 4</option>
                </select>
            </div><br>
            <div class="buffer">
                O:
                <input type="button" value="Rename" onclick=""> 
                <input type="button" value="Delete" onclick=""> 
                <input type="button" value="Render" onclick=""> 
                <select class="buffer-select">
                    <option value="1">Buffer 1</option>
                    <option value="2">Buffer 2</option>
                    <option value="3">Buffer 3</option>
                    <option value="4">Buffer 4</option>
                </select>
            </div>
        </div>
    </div>
</body>
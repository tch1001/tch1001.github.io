<style>
    .actions-panel {
        position: fixed;
        top: 0;
        left: 0;
    }
    .input-panel {
        position: fixed;
        left: 120px;
    }
    .toggle-textarea {
        top: 0;
        left: 0;
        width: 120px;
    }

    .overlay {
        position: fixed;
        top: 0;
        left: 0;
    }

    body {
        margin: 0;
        padding: 0;
    }

    .buffers {
        position: fixed;
        bottom: 0;
        left: 0;
    }
    .buffer {
        position: relative;
        display: inline-block;
        margin-bottom: 20px;
    }
    #delimiter-textfield {
        width: 30px;
    }
</style>
<script>
    MathJax = {
        loader: { load: ['output/svg'] }
    };
</script>
<script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js"></script>
<script>
    // create a javascript class for each equation
    const MouseState = {
        NONE: 0,
        HOVER: 1,
        SELECTED: 2,
        DRAGGING: 3,
    }
    function removedAligned(code){
        return code.replace('\\begin{aligned}', '').replace('\\end{aligned}', '');
    }
    focused_entity = null;
    function decorateNode(entity,node){
        console.log('inside decorate', entity)
        node.style.position = 'absolute';
        node.style.right = entity.position.right;
        node.style.top = entity.position.top;
        node.onmousedown = entity.onmousedown.bind(entity);
        node.onmousemove = entity.onmousemove.bind(entity);
        node.onmouseup = entity.onmouseup.bind(entity);
        node.onmouseover = entity.onmouseover.bind(entity);
        node.onmouseout = entity.onmouseout.bind(entity);
    }
    document.onmousedown = function (e){
        if(e.target == document.body){
            // unselect the focused entity
            if(focused_entity != null){
                document.getElementById('latex').value = '';
                focused_entity = null;
            }
        }
    }
    function math_rerender(code, entity){
        document.getElementById('output').removeChild(entity.node);
        MathJax.tex2svgPromise(code).then((node) => {
            console.log(node.children[0])
            entity.node = node.children[0];
            decorateNode(entity, entity.node);
            document.getElementById('output').appendChild(entity.node)
        }).catch((err) => {
            console.log("err")
        })
    }
    function latex_onkeyup() {
        console.log('keyup')
        if(document.getElementById('auto-render').checked){
            var textarea = document.getElementById('latex');
            var code = textarea.value;
            code = removedAligned(code);
            code = "\\begin{aligned}" + code + "\\end{aligned}"
            console.log(code)
            if(focused_entity != null){
                focused_entity.code = code;
                math_rerender(code, focused_entity);
            }
        }
    }
    function get_selection() {
        var textarea = document.getElementById('latex');
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;
        var sel = textarea.value.substring(start, end);
        return [start, end, sel];
    }
    function latex_onmouseup(e) {
        // get selection
        save_old_textarea_style();
        var [start, end, sel] = get_selection();
        if (sel.length == 0) {
            return;
        }
        // surround with underbrace
        var textarea = document.getElementById('latex');
        var before = textarea.value.substring(0, start);
        var after = textarea.value.substring(end, textarea.value.length);
        // trim whitespaces at the back of sel
        var i = sel.length - 1;
        while (sel[i] == ' ') {
            i--;
        }
        sel = sel.substring(0, i + 1);
        // if the last 2 characters of sel are newlines \\
        var hadNewline = false;
        if (sel[sel.length - 1] == '\\' && sel[sel.length - 2] == '\\') {
            sel = sel.substring(0, sel.length - 2);
            hadNewline = true;
        }
        var underbraced = before + (sel.includes('&') ? '&' : '' ) 
                                    + "\\underbrace{" + sel.replaceAll('&','') + "}" 
                                    + (hadNewline ? '\\\\' : '')
                                    + after;
        underbraced = "\\begin{aligned}" + removedAligned(underbraced) + "\\end{aligned}"
        math_rerender(underbraced, focused_entity);
    }
    class Entity {
        constructor(code, node) {
            this.code = code;
            this.node = node;
            this.position = {};
            this.position.right = node.style.right;
            this.position.top = node.style.top;
            this.mouse_state = MouseState.NONE;
        }
        onmouseover(e) {
            if (this.mouse_state != MouseState.DRAGGING) this.mouse_state = MouseState.HOVER;
            this.node.style.border = '1px solid red';
        }
        onmousedown(e) {
            if (e.button == 0) { // left click
                if (this.mouse_state != MouseState.DRAGGING) this.mouse_state = MouseState.SELECTED;
                this.node.style.border = '1px solid blue';
            }else if (e.button == 2) { // right click
                this.mouse_state = MouseState.NONE;
                // select the node
                document.getElementById('latex').value = removedAligned(this.code);
                toggle_textarea(1);
                this.node.style.border = '1px solid green';
                focused_entity = this;
                return;
            }
        }
        onmouseout(e) {
            // console.log('out', e);
            if(focused_entity != this){
                this.node.style.border = '1px solid white';
            }
        }
        onmouseup(e) {
            // console.log('up', e)
            if (e.button == 0) { // left click
                this.mouse_state = MouseState.NONE;
            }
            if(focused_entity != this){
                this.node.style.border = '1px solid white';
            }
        }
        onmousemove(e) {
            if (this.mouse_state == MouseState.SELECTED) {
                this.mouse_state = MouseState.DRAGGING;
            }
            if (this.mouse_state == MouseState.DRAGGING) {
                // change in x and y
                var dx = e.movementX;
                var dy = e.movementY;
                // scale
                const scale = 0.5;
                dx *= scale;
                dy *= scale;
                // move the node
                this.position.right = parseInt(this.position.right) - dx;
                this.position.top = parseInt(this.position.top) + dy;
                this.node.style.right = this.position.right;
                this.node.style.top = this.position.top;
            }
        }
    }
    var entities = [];
    document.addEventListener('contextmenu', event => event.preventDefault());

    function math_render(code, location=null) { // optional location
        MathJax.tex2svgPromise(code).then((guy) => {
            // console.log(node.children[0])
            // absolute positioning for node 
            var node = guy.children[0];
            node.style.position = 'absolute';
            if(location == null){
                node.style.top = 0;
                node.style.right = 0;
            }else{
                node.style.top = location.top;
                node.style.right = location.right;
            }
            const entity = new Entity(code, node);
            decorateNode(entity,node);
            entities.push(entity);
            document.getElementById('output').appendChild(node)
        }).catch((err) => {
            console.log("err")
        })
    }
    function init() {
        document.onmouseup = function (e) {
            for (var i = 0; i < entities.length; i++) {
                entities[i].onmouseup(e);
            }
        }
        document.onmousemove = function (e) {
            for (var i = 0; i < entities.length; i++) {
                entities[i].onmousemove(e);
            }
        }
        document.getElementById('latex').style.visibility = 'hidden';
        math_render('\\begin{aligned} \\left(d+e-\\left[f-g\\right]\\right)\\end{aligned}', {top: 200, right: 150})
        math_render('\\begin{aligned} -(a+b) \\end{aligned}', {top: 160, right: 230})
    }
    function add_entity(location=null){
        const raw_latex = document.getElementById('latex').value;
        if(raw_latex.length == 0) return;
        // wrap with aligned
        const aligned = '\\begin{aligned}' + removedAligned(raw_latex) + '\\end{aligned}';
        math_render(aligned, location);
    }
    function render() {
        init()
        add_entity({top: 200, right: 200})
    }
    function delete_entity(){
        if(focused_entity == null) return;
        document.getElementById('output').removeChild(focused_entity.node);
        document.getElementById('latex').value = '';
        focused_entity = null;
    }
    var old_textarea_style = {
        width: '400px',
        height: '150px',
    };
    function save_old_textarea_style(){
        var textarea = document.getElementById('latex');
        old_textarea_style = {
            width: textarea.style.width,
            height: textarea.style.height,
        }
    }
    function show_textarea(){
        var textarea = document.getElementById('latex');
        textarea.style.visibility = 'visible';
        textarea.style.width = old_textarea_style.width
        textarea.style.height = old_textarea_style.height
    }
    function toggle_textarea(force) {
        if(force == 1){
            show_textarea();
            return;
        }
        var textarea = document.getElementById('latex');
        if (textarea.style.visibility == 'hidden') {
            show_textarea();
        } else {
            textarea.style.visibility = 'hidden';
            save_old_textarea_style();
            textarea.style.width = '0px';
            textarea.style.height = '0px';
        }
    }
    var equation_buffers = [];
    function separate(){
        console.log('separate')
        const delimiter = document.getElementById('delimiter-textfield').value;
        const firstDelimiter = delimiter.split(',')[0];
        const secondDelimiter = delimiter.split(',')[1]; // the minus sign
        var [start, end, sel] = get_selection();
        if(sel.length == 0) sel = removedAligned(focused_entity.code); // if nothing selected, entire thing is selected
        // split sel by firstDelimiter (plus sign) and secondDelimiter (minus sign)
        // taking good care of brackets
        const brackets = [['(', ')'], ['{', '}'], ['[', ']']];
        var bracket_stack = [];
        /*
        task: split sel by firstDelimiter and secondDelimiter, but only up to the first level, meaning
        if there are brackets, don't split inside the brackets
        e.g. (a+b+c) + (d+e+f) - x should be split into (a+b+c), (d+e+f) and x

        algorithm: every character has a "level", which is the number of brackets that it is inside
        at the end, we just split by the delimiters of level 0
        */
        var terms = [];
        var prev_idx = 0;
        for(var i=0;i<sel.length;i++){
            var char = sel[i];
            const level = bracket_stack.length;
            if(char == firstDelimiter && level == 0){
                // split here
                terms.push(sel.substring(prev_idx, i));
                prev_idx = i+1;
            }else if(char == secondDelimiter && level == 0){
                // split here
                terms.push(sel.substring(prev_idx, i));
                prev_idx = i+1;
            }else{
                // check if char is a bracket
                for(var j=0;j<brackets.length;j++){
                    if(char == brackets[j][0]){
                        // push to stack
                        bracket_stack.push(char);
                    }else if(char == brackets[j][1]){
                        // pop from stack
                        bracket_stack.pop();
                    }
                }
            }
        }
        // add the last term
        terms.push(sel.substring(prev_idx, sel.length));
        console.log(terms)
        var equation_buffer = [];
        for(var i=0;i<terms.length;i++){
            // if all whitespaces
            const current_term = terms[i];
            if(current_term.replace(/\s/g, '').length == 0) continue;
            // render
            equation_buffer.push(current_term);
        }
        add_buffer('sep-'+equation_buffers.length, equation_buffer);
        render_buffer(document.getElementById('buffer-a-display'), equation_buffer);
    }
    function add_buffer(name, equation_buffer=[]){
        const buffer = {
            name: name,
            equations: equation_buffer,
        }
        equation_buffers.push(buffer);
        // add new option in dropdown list
        const buffer_selects = document.getElementsByClassName('buffer-select')
        for(var i=0;i<buffer_selects.length;i++){
            const buffer_select = buffer_selects[i];
            const option = document.createElement('option');
            option.value = equation_buffers.length - 1;
            option.innerHTML = name;
            buffer_select.appendChild(option);
        }
    }
    function buffer_display_onselect(){
        // className buffer-select
        const buffer_selects = document.getElementsByClassName('buffer-select')
        for(var i=0; i< buffer_selects.length;i++){
            const buffer_select = buffer_selects[i];
            const buffer_idx = buffer_select.value;
            const buffer = equation_buffers[buffer_idx];
            const which_buffer = buffer_select.id.split('-')[1]; // a,b,o
            const buffer_display_element = document.getElementById('buffer-' + which_buffer + '-display');
            render_buffer(buffer_display_element, buffer.equations, which_buffer, buffer_idx);
        }
    }
    function buffer_display_onscroll(e){
        console.log('scroll')
    }
    function term_onclick(e){
            var target = e.target;
            var timeout = 100;
            while(target.getElementsByClassName('code').length == 0){
                if(timeout-- < 0) break; // prevent infinite loop
                target = target.parentElement;
            }
            const code = target.getElementsByClassName('code')[0].innerHTML;
            document.getElementById('latex').value = code;
            toggle_textarea(1);
            focused_entity = null;
    }
    function render_buffer(buffer_display_element, equation_buffer, display='a', idx=equation_buffers.length-1){
        // clear the buffer
        buffer_display_element.innerHTML = '';
        // render the buffer
        console.log('rendering buffer', equation_buffer)
        for(var i=0;i<equation_buffer.length;i++){
            const code = equation_buffer[i];
            MathJax.tex2svgPromise('\\begin{aligned}' + code + '\\end{aligned}').then((node) => {
                const child_element = buffer_display_element.appendChild(node.children[0]);
                child_element.style = 'border: 1px solid black; padding-left: 5px; padding-right: 5px; margin-right: 5px; margin-left: 5px;';
                const metadata = child_element.appendChild(document.createElement('span'))
                metadata.style = 'display: none;'
                metadata.classList.add('code');
                metadata.innerHTML = code;
                child_element.onclick = term_onclick;
            }).catch((err) => {
                console.error(error)
            })
        }
        // display the correct thing in the dropdown 
        document.getElementById('buffer-' + display).getElementsByClassName('buffer-select')[0].value = idx
    }
</script>

<body onload='render()'>

    <!-- <canvas class='workspace' id='output' width='500' height='500'></canvas> -->
    <div id='output'></div>
    <div class="overlay add-entity">
        <div class="input-panel">
            <textarea class="latex-input" id='latex' onkeyup="latex_onkeyup()" onmouseup="latex_onmouseup()">
  W_\alpha &= -\frac{1}{4} \bar{D}^2 D_\alpha V \\
  &= -\frac{1}{4} \bar{D}^2 (-\sigma^\nu_{\alpha\dot\beta} \bar\theta^{\dot\beta} A_\nu + i\theta_\alpha \overline{\theta\lambda} - i \bar\theta^2 \lambda_\alpha + \frac{1}{2} \theta_\alpha \bar{\theta}^2 D - i \sigma_{\alpha \dot\alpha}^\mu \bar\theta^{\dot\alpha} \theta^\beta \sigma_{\beta\dot\beta}^\nu \bar\theta^{\dot\beta} \partial_\mu A_\nu - \sigma_{\alpha \dot \alpha}^\mu \bar\theta^{\dot\alpha} \theta^\beta \theta_\beta \bar\theta^{\dot\beta} \partial_\mu \bar\lambda_{\dot\beta}) \\
  &= (a+b-c) + (d-e+f) - x \\
</textarea><br>
        </div>
        <div class="actions-panel">
            <button class="toggle-textarea" onclick="toggle_textarea()">Toggle Textarea</button><br>
            <button class="add-entity" onclick="add_entity()">Add Entity</button><br>
            <button class="delete-entity" onclick="delete_entity()">Delete</button><br>
            <input type="checkbox" id="auto-render" checked onchange="latex_onkeyup()"> Auto-Render
        </div>
        <div class="buffers">
            <input type="button" value="Copy Buffer" onclick=""> <br> 
            <input type="button" value="Expand" onclick=""> <br> 
            <input type="button" value="Separate" onclick="separate()"> 
            <input type="text" placeholder="Delimiter" value="+,-" id="delimiter-textfield"><br>
            <div id="buffer-a">
                A:
                <input type="button" value="Rename" onclick=""> 
                <input type="button" value="Delete" onclick=""> 
                <input type="button" value="Render" onclick=""> 
                <select id="buffer-a-select" class="buffer-select" onchange="buffer_display_onselect()" onscroll="buffer_display_onscroll">
                </select>
                <span id="buffer-a-display">Choose a Buffer</span>
            </div><br>
            <div id="buffer-b">
                B:
                <input type="button" value="Rename" onclick=""> 
                <input type="button" value="Delete" onclick=""> 
                <input type="button" value="Render" onclick=""> 
                <select id="buffer-b-select" class="buffer-select" onchange="buffer_display_onselect()" onscroll="buffer_display_onscroll">
                </select>
                <span id="buffer-b-display">Choose a Buffer</span>
            </div><br>
            <div id="buffer-o">
                O:
                <input type="button" value="Rename" onclick=""> 
                <input type="button" value="Delete" onclick=""> 
                <input type="button" value="Render" onclick=""> 
                <select id="buffer-o-select" class="buffer-select" onchange="buffer_display_onselect()" onscroll="buffer_display_onscroll">
                </select>
                <span id="buffer-o-display">Choose a Buffer</span>
            </div>
        </div>
    </div>
</body>
<style>
    .actions-panel {
        position: fixed;
        top: 0;
        left: 0;
    }
    .input-panel {
        position: fixed;
        left: 120px;
    }
    .toggle-textarea {
        top: 0;
        left: 0;
        width: 120px;
    }

    .overlay {
        position: fixed;
        top: 0;
        left: 0;
    }

    body {
        margin: 0;
        padding: 0;
    }
</style>
<script>
    MathJax = {
        loader: { load: ['output/svg'] }
    };
</script>
<script id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-svg.js"></script>
<script>
    // create a javascript class for each equation
    const MouseState = {
        NONE: 0,
        HOVER: 1,
        SELECTED: 2,
        DRAGGING: 3,
    }
    function removedAligned(code){
        return code.replace('\\begin{aligned}', '').replace('\\end{aligned}', '');
    }
    focused_entity = null;
    function decorateNode(entity,node){
        console.log('inside decorate', entity)
        node.style.position = 'absolute';
        node.style.right = entity.position.right;
        node.style.top = entity.position.top;
        node.onmousedown = entity.onmousedown.bind(entity);
        node.onmousemove = entity.onmousemove.bind(entity);
        node.onmouseup = entity.onmouseup.bind(entity);
        node.onmouseover = entity.onmouseover.bind(entity);
        node.onmouseout = entity.onmouseout.bind(entity);
    }
    document.onmousedown = function (e){
        if(e.target == document.body){
            // unselect the focused entity
            if(focused_entity != null){
                document.getElementById('latex').value = '';
                focused_entity = null;
            }
        }
    }
    function math_rerender(code, entity){
        document.getElementById('output').removeChild(entity.node);
        MathJax.tex2svgPromise(code).then((node) => {
            console.log(node.children[0])
            entity.node = node.children[0];
            decorateNode(entity, entity.node);
            document.getElementById('output').appendChild(entity.node)
        }).catch((err) => {
            console.log("err")
        })
    }
    function latex_onkeyup() {
        console.log('keyup')
        if(document.getElementById('auto-render').checked){
            var textarea = document.getElementById('latex');
            var code = textarea.value;
            code = removedAligned(code);
            code = "\\begin{aligned}" + code + "\\end{aligned}"
            console.log(code)
            if(focused_entity != null){
                focused_entity.code = code;
                math_rerender(code, focused_entity);
            }
        }
    }
    function get_selection() {
        var textarea = document.getElementById('latex');
        var start = textarea.selectionStart;
        var end = textarea.selectionEnd;
        var sel = textarea.value.substring(start, end);
        return [start, end, sel];
    }
    function latex_onmouseup(e) {
        // get selection
        save_old_textarea_style();
        const [start, end, sel] = get_selection();
        if (sel.length == 0) {
            return;
        }
        // surround with underbrace
        var textarea = document.getElementById('latex');
        var before = textarea.value.substring(0, start);
        var after = textarea.value.substring(end, textarea.value.length);
        var underbraced = before + "\\underbrace{" + sel + "}" + after;
        underbraced = "\\begin{aligned}" + removedAligned(underbraced) + "\\end{aligned}"
        console.log(underbraced)
        math_rerender(underbraced, focused_entity);
    }
    class Entity {
        constructor(code, node) {
            this.code = code;
            this.node = node;
            this.position = {};
            this.position.right = node.style.right;
            this.position.top = node.style.top;
            this.mouse_state = MouseState.NONE;
        }
        onmouseover(e) {
            if (this.mouse_state != MouseState.DRAGGING) this.mouse_state = MouseState.HOVER;
            this.node.style.border = '1px solid red';
        }
        onmousedown(e) {
            if (e.button == 0) { // left click
                if (this.mouse_state != MouseState.DRAGGING) this.mouse_state = MouseState.SELECTED;
                this.node.style.border = '1px solid blue';
            }else if (e.button == 2) { // right click
                this.mouse_state = MouseState.NONE;
                // select the node
                document.getElementById('latex').value = removedAligned(this.code);
                toggle_textarea(1);
                this.node.style.border = '1px solid green';
                focused_entity = this;
                return;
            }
        }
        onmouseout(e) {
            // console.log('out', e);
            if(focused_entity != this){
                this.node.style.border = '1px solid white';
            }
        }
        onmouseup(e) {
            // console.log('up', e)
            if (e.button == 0) { // left click
                this.mouse_state = MouseState.NONE;
            }
            if(focused_entity != this){
                this.node.style.border = '1px solid white';
            }
        }
        onmousemove(e) {
            if (this.mouse_state == MouseState.SELECTED) {
                this.mouse_state = MouseState.DRAGGING;
            }
            if (this.mouse_state == MouseState.DRAGGING) {
                // change in x and y
                var dx = e.movementX;
                var dy = e.movementY;
                // scale
                const scale = 0.5;
                dx *= scale;
                dy *= scale;
                // move the node
                this.position.right = parseInt(this.position.right) - dx;
                this.position.top = parseInt(this.position.top) + dy;
                this.node.style.right = this.position.right;
                this.node.style.top = this.position.top;
            }
        }
    }
    var entities = [];
    document.addEventListener('contextmenu', event => event.preventDefault());

    function math_render(code) {
        MathJax.tex2svgPromise(code).then((guy) => {
            // console.log(node.children[0])
            // absolute positioning for node 
            var node = guy.children[0];
            node.style.position = 'absolute';
            node.style.top = 0;
            node.style.right = 0;
            const entity = new Entity(code, node);
            decorateNode(entity,node);
            entities.push(entity);
            document.getElementById('output').appendChild(node)
        }).catch((err) => {
            console.log("err")
        })
    }
    function init() {
        document.onmouseup = function (e) {
            for (var i = 0; i < entities.length; i++) {
                entities[i].onmouseup(e);
            }
        }
        document.onmousemove = function (e) {
            for (var i = 0; i < entities.length; i++) {
                entities[i].onmousemove(e);
            }
        }
        document.getElementById('latex').style.visibility = 'hidden';
    }
    function add_entity(){
        const raw_latex = document.getElementById('latex').value;
        if(raw_latex.length == 0) return;
        // wrap with aligned
        const aligned = '\\begin{aligned}' + removedAligned(raw_latex) + '\\end{aligned}';
        math_render(aligned);
    }
    function render() {
        init()
        add_entity()
    }
    function delete_entity(){
        if(focused_entity == null) return;
        document.getElementById('output').removeChild(focused_entity.node);
        document.getElementById('latex').value = '';
        focused_entity = null;
    }
    var old_textarea_style = {};
    function save_old_textarea_style(){
        var textarea = document.getElementById('latex');
        old_textarea_style = {
            width: textarea.style.width,
            height: textarea.style.height,
        }
    }
    function show_textarea(){
        var textarea = document.getElementById('latex');
        textarea.style.visibility = 'visible';
        textarea.style.width = old_textarea_style.width
        textarea.style.height = old_textarea_style.height
    }
    function toggle_textarea(force) {
        if(force == 1){
            show_textarea();
            return;
        }
        var textarea = document.getElementById('latex');
        if (textarea.style.visibility == 'hidden') {
            show_textarea();
        } else {
            textarea.style.visibility = 'hidden';
            save_old_textarea_style();
            textarea.style.width = '0px';
            textarea.style.height = '0px';
        }
    }
</script>

<body onload='render()'>

    <!-- <canvas class='workspace' id='output' width='500' height='500'></canvas> -->
    <div id='output'></div>
    <div class="overlay add-entity">
        <div class="input-panel">
            <textarea class="latex-input" id='latex' onkeyup="latex_onkeyup()" onmouseup="latex_onmouseup()">
  W_\alpha &= -\frac{1}{4} \bar{D}^2 D_\alpha V \\
  &= -\frac{1}{4} \bar{D}^2 (-\sigma^\nu_{\alpha\dot\beta} \bar\theta^{\dot\beta} A_\nu + i\theta_\alpha \overline{\theta\lambda} - i \bar\theta^2 \lambda_\alpha + \frac{1}{2} \theta_\alpha \bar{\theta}^2 D - i \sigma_{\alpha \dot\alpha}^\mu \bar\theta^{\dot\alpha} \theta^\beta \sigma_{\beta\dot\beta}^\nu \bar\theta^{\dot\beta} \partial_\mu A_\nu - \sigma_{\alpha \dot \alpha}^\mu \bar\theta^{\dot\alpha} \theta^\beta \theta_\beta \bar\theta^{\dot\beta} \partial_\mu \bar\lambda_{\dot\beta}) \\
  &= (a+b-c) (d-e +f)\\
</textarea><br>
        </div>
        <div class="actions-panel">
            <button class="toggle-textarea" onclick="toggle_textarea()">Toggle Textarea</button><br>
            <button class="add-entity" onclick="add_entity()">Add Entity</button><br>
            <button class="delete-entity" onclick="delete_entity()">Delete</button><br>
            <input type="checkbox" id="auto-render" checked onchange="latex_onkeyup()"> Auto-Render
        </div>
    </div>
</body>